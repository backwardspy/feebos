#! /usr/bin/env python3
# pylint: disable=missing-module-docstring,missing-function-docstring


import json
import subprocess
import sys
from pathlib import Path
from typing import Optional


def get_build_type() -> str:
    if len(sys.argv) > 1 and sys.argv[1] == "release":
        return "release"
    return "debug"


TARGET = "x86_64-feebos"
TARGET_PATH = Path("target") / TARGET / get_build_type()
KERNEL_PATH = TARGET_PATH / "feebos"


def log_command(cmd_parts: list[str], *, cwd: Optional[str] = None) -> None:
    print(f"executing: {' '.join(cmd_parts)}")
    if cwd:
        print(f"  ^ in {cwd}")


def build_bootable_image(bootloader_manifest_path: Path) -> None:
    command = [
        "cargo",
        "builder",
        "--kernel-manifest",
        str(Path.cwd() / "Cargo.toml"),
        "--kernel-binary",
        str(KERNEL_PATH.absolute()),
        "--target-dir",
        str(TARGET_PATH.absolute()),
        "--out-dir",
        str(KERNEL_PATH.parent.absolute()),
    ]
    log_command(command, cwd=str(bootloader_manifest_path.parent))
    subprocess.check_call(command, cwd=bootloader_manifest_path.parent)


def find_bootloader_manifest() -> Path:
    packages = json.loads(
        subprocess.check_output(["cargo", "metadata", "--format-version", "1"])
    )["packages"]
    for package in packages:
        if package["name"] == "bootloader":
            return Path(package["manifest_path"])

    raise RuntimeError("Could not find bootloader manifest")


def make_bootable_image() -> None:
    bootloader_manifest_path = find_bootloader_manifest()
    build_bootable_image(bootloader_manifest_path)


def build() -> None:
    build_cmd = ["cargo", "build"]
    if get_build_type() == "release":
        build_cmd.append("--release")
    log_command(build_cmd)
    subprocess.check_call(build_cmd)
    make_bootable_image()


if __name__ == "__main__":
    build()
